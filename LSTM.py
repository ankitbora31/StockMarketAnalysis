{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef113d50",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "print(tf.__version__)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "51123213",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "import pandas as pd\n",
    "from pandas.plotting import lag_plot\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "from datetime import datetime\n",
    "import yfinance as yf\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense\n",
    "from keras.layers import Dropout\n",
    "from keras.layers import LSTM\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94b55671",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_data(quote):\n",
    "    end = datetime.now()\n",
    "    start = datetime(end.year-2,end.month,end.day)\n",
    "    data = yf.download(quote,start=start,end=end)\n",
    "    df = pd.DataFrame(data = data)\n",
    "    df.to_csv(''+quote+'.csv')\n",
    "    if df.empty:\n",
    "        data = data.head(503).iloc[::-1]\n",
    "        data = data.reset_index()\n",
    "        \n",
    "        df = pd.DataFrame()\n",
    "        df=pd.DataFrame()\n",
    "        df['Date']=data['date']\n",
    "        df['Open']=data['1. open']\n",
    "        df['High']=data['2. high']\n",
    "        df['Low']=data['3. low']\n",
    "        df['Close']=data['4. close']\n",
    "        df['Adj Close']=data['5. adjusted close']\n",
    "        df['Volume']=data['6. volume']\n",
    "        df.to_csv(''+quote+'.csv',index=False)\n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b0cde51",
   "metadata": {},
   "outputs": [],
   "source": [
    "quote = 'ZOMATO.NS'\n",
    "df = get_data(quote)\n",
    "\n",
    "df['Date'] = df.index\n",
    "df.reset_index(drop=True, inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4d8923d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "def LSTM_ALGO(df):\n",
    "        #Split data into training set and test set\n",
    "        dataset_train=df.iloc[0:int(0.8*len(df)),:]\n",
    "        dataset_test=df.iloc[int(0.8*len(df)):,:]\n",
    "        ############# NOTE #################\n",
    "        #TO PREDICT STOCK PRICES OF NEXT N DAYS, STORE PREVIOUS N DAYS IN MEMORY WHILE TRAINING\n",
    "        # HERE N=7\n",
    "        ###dataset_train=pd.read_csv('Google_Stock_Price_Train.csv')\n",
    "        training_set=df.iloc[:,4:5].values# 1:2, to store as numpy array else Series obj will be stored\n",
    "        #select cols using above manner to select as float64 type, view in var explorer\n",
    "\n",
    "        #Feature Scaling\n",
    "        from sklearn.preprocessing import MinMaxScaler\n",
    "        sc=MinMaxScaler(feature_range=(0,1))#Scaled values btween 0,1\n",
    "        training_set_scaled=sc.fit_transform(training_set)\n",
    "        #In scaling, fit_transform for training, transform for test\n",
    "        \n",
    "        #Creating data stucture with 7 timesteps and 1 output. \n",
    "        #7 timesteps meaning storing trends from 7 days before current day to predict 1 next output\n",
    "        X_train=[]#memory with 7 days from day i\n",
    "        y_train=[]#day i\n",
    "        for i in range(7,len(training_set_scaled)):\n",
    "            X_train.append(training_set_scaled[i-7:i,0])\n",
    "            y_train.append(training_set_scaled[i,0])\n",
    "        #Convert list to numpy arrays\n",
    "        X_train=np.array(X_train)\n",
    "        y_train=np.array(y_train)\n",
    "        X_forecast=np.array(X_train[-1,1:])\n",
    "        X_forecast=np.append(X_forecast,y_train[-1])\n",
    "        #Reshaping: Adding 3rd dimension\n",
    "        X_train=np.reshape(X_train, (X_train.shape[0],X_train.shape[1],1))#.shape 0=row,1=col\n",
    "        X_forecast=np.reshape(X_forecast, (1,X_forecast.shape[0],1))\n",
    "\n",
    "        regressor=Sequential()\n",
    "        \n",
    "        #Add first LSTM layer\n",
    "        regressor.add(LSTM(units=50,return_sequences=True,input_shape=(X_train.shape[1],1)))\n",
    "        #units=no. of neurons in layer\n",
    "        #input_shape=(timesteps,no. of cols/features)\n",
    "        #return_seq=True for sending recc memory. For last layer, retrun_seq=False since end of the line\n",
    "        regressor.add(Dropout(0.1))\n",
    "        \n",
    "        #Add 2nd LSTM layer\n",
    "        regressor.add(LSTM(units=50,return_sequences=True))\n",
    "        regressor.add(Dropout(0.1))\n",
    "        \n",
    "        #Add 3rd LSTM layer\n",
    "        regressor.add(LSTM(units=50,return_sequences=True))\n",
    "        regressor.add(Dropout(0.1))\n",
    "        \n",
    "        #Add 4th LSTM layer\n",
    "        regressor.add(LSTM(units=50))\n",
    "        regressor.add(Dropout(0.1))\n",
    "        \n",
    "        #Add o/p layer\n",
    "        regressor.add(Dense(units=1))\n",
    "        \n",
    "        #Compile\n",
    "        regressor.compile(optimizer='adam',loss='mean_squared_error')\n",
    "        \n",
    "        #Training\n",
    "        regressor.fit(X_train,y_train,epochs=25,batch_size=32 )\n",
    "        #For lstm, batch_size=power of 2\n",
    "        \n",
    "        #Testing\n",
    "        ###dataset_test=pd.read_csv('Google_Stock_Price_Test.csv')\n",
    "        real_stock_price=dataset_test.iloc[:,4:5].values\n",
    "        \n",
    "        #To predict, we need stock prices of 7 days before the test set\n",
    "        #So combine train and test set to get the entire data set\n",
    "        dataset_total=pd.concat((dataset_train['Close'],dataset_test['Close']),axis=0) \n",
    "        testing_set=dataset_total[ len(dataset_total) -len(dataset_test) -7: ].values\n",
    "        testing_set=testing_set.reshape(-1,1)\n",
    "        #-1=till last row, (-1,1)=>(80,1). otherwise only (80,0)\n",
    "        \n",
    "        #Feature scaling\n",
    "        testing_set=sc.transform(testing_set)\n",
    "        \n",
    "        #Create data structure\n",
    "        X_test=[]\n",
    "        for i in range(7,len(testing_set)):\n",
    "            X_test.append(testing_set[i-7:i,0])\n",
    "            #Convert list to numpy arrays\n",
    "        X_test=np.array(X_test)\n",
    "        \n",
    "        #Reshaping: Adding 3rd dimension\n",
    "        X_test=np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))\n",
    "        \n",
    "        #Testing Prediction\n",
    "        predicted_stock_price=regressor.predict(X_test)\n",
    "        \n",
    "        #Getting original prices back from scaled values\n",
    "        predicted_stock_price=sc.inverse_transform(predicted_stock_price)\n",
    "        fig = plt.figure(figsize=(7.2,4.8),dpi=65)\n",
    "        plt.plot(real_stock_price,label='Actual Price')  \n",
    "        plt.plot(predicted_stock_price,label='Predicted Price')\n",
    "          \n",
    "        plt.legend(loc=4)\n",
    "        plt.show()        \n",
    "        \n",
    "        error_lstm = math.sqrt(mean_squared_error(real_stock_price, predicted_stock_price))\n",
    "        \n",
    "        \n",
    "        #Forecasting Prediction\n",
    "        forecasted_stock_price=regressor.predict(X_forecast)\n",
    "        \n",
    "        #Getting original prices back from scaled values\n",
    "        forecasted_stock_price=sc.inverse_transform(forecasted_stock_price)\n",
    "        \n",
    "        lstm_pred=forecasted_stock_price[0,0]\n",
    "        print()\n",
    "        print(\"##############################################################################\")\n",
    "        print(\"Tomorrow's \",quote,\" Closing Price Prediction by LSTM: \",lstm_pred)\n",
    "        print(\"LSTM RMSE:\",error_lstm)\n",
    "        print(\"##############################################################################\")\n",
    "        return lstm_pred,error_lstm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6780e00f",
   "metadata": {},
   "outputs": [],
   "source": [
    "LSTM_ALGO(df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b54686e",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
